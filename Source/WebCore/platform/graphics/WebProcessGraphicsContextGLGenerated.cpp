/* Copyright (C) 2023 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// This file is generated by generate-gpup-webgl. Do not edit.

#include "config.h"

#include "WebProcessGraphicsContextGL.h"

namespace WebCore {

void WebProcessGraphicsContextGL::activeTexture(GCGLenum texture)
{
    if (!makeContextCurrent())
        return;
    m_context->activeTexture(texture);
}

void WebProcessGraphicsContextGL::attachShader(PlatformGLObject program, PlatformGLObject shader)
{
    if (!makeContextCurrent())
        return;
    m_context->attachShader(program, shader);
}

void WebProcessGraphicsContextGL::bindAttribLocation(PlatformGLObject arg0, GCGLuint index, const String& name)
{
    if (!makeContextCurrent())
        return;
    m_context->bindAttribLocation(arg0, index, name);
}

void WebProcessGraphicsContextGL::bindBuffer(GCGLenum target, PlatformGLObject arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->bindBuffer(target, arg1);
}

void WebProcessGraphicsContextGL::bindFramebuffer(GCGLenum target, PlatformGLObject arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->bindFramebuffer(target, arg1);
}

void WebProcessGraphicsContextGL::bindRenderbuffer(GCGLenum target, PlatformGLObject arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->bindRenderbuffer(target, arg1);
}

void WebProcessGraphicsContextGL::bindTexture(GCGLenum target, PlatformGLObject arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->bindTexture(target, arg1);
}

void WebProcessGraphicsContextGL::blendColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha)
{
    if (!makeContextCurrent())
        return;
    m_context->blendColor(red, green, blue, alpha);
}

void WebProcessGraphicsContextGL::blendEquation(GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->blendEquation(mode);
}

void WebProcessGraphicsContextGL::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)
{
    if (!makeContextCurrent())
        return;
    m_context->blendEquationSeparate(modeRGB, modeAlpha);
}

void WebProcessGraphicsContextGL::blendFunc(GCGLenum sfactor, GCGLenum dfactor)
{
    if (!makeContextCurrent())
        return;
    m_context->blendFunc(sfactor, dfactor);
}

void WebProcessGraphicsContextGL::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)
{
    if (!makeContextCurrent())
        return;
    m_context->blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
}

GCGLenum WebProcessGraphicsContextGL::checkFramebufferStatus(GCGLenum target)
{
    if (!makeContextCurrent())
        return { };
    return m_context->checkFramebufferStatus(target);
}

void WebProcessGraphicsContextGL::clear(GCGLbitfield mask)
{
    if (!makeContextCurrent())
        return;
    m_context->clear(mask);
}

void WebProcessGraphicsContextGL::clearColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha)
{
    if (!makeContextCurrent())
        return;
    m_context->clearColor(red, green, blue, alpha);
}

void WebProcessGraphicsContextGL::clearDepth(GCGLclampf depth)
{
    if (!makeContextCurrent())
        return;
    m_context->clearDepth(depth);
}

void WebProcessGraphicsContextGL::clearStencil(GCGLint s)
{
    if (!makeContextCurrent())
        return;
    m_context->clearStencil(s);
}

void WebProcessGraphicsContextGL::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)
{
    if (!makeContextCurrent())
        return;
    m_context->colorMask(red, green, blue, alpha);
}

void WebProcessGraphicsContextGL::compileShader(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->compileShader(arg0);
}

void WebProcessGraphicsContextGL::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)
{
    if (!makeContextCurrent())
        return;
    m_context->copyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

void WebProcessGraphicsContextGL::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

PlatformGLObject WebProcessGraphicsContextGL::createBuffer()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createBuffer();
}

PlatformGLObject WebProcessGraphicsContextGL::createFramebuffer()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createFramebuffer();
}

PlatformGLObject WebProcessGraphicsContextGL::createProgram()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createProgram();
}

PlatformGLObject WebProcessGraphicsContextGL::createRenderbuffer()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createRenderbuffer();
}

PlatformGLObject WebProcessGraphicsContextGL::createShader(GCGLenum arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->createShader(arg0);
}

PlatformGLObject WebProcessGraphicsContextGL::createTexture()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createTexture();
}

void WebProcessGraphicsContextGL::cullFace(GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->cullFace(mode);
}

void WebProcessGraphicsContextGL::deleteBuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteBuffer(arg0);
}

void WebProcessGraphicsContextGL::deleteFramebuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteFramebuffer(arg0);
}

void WebProcessGraphicsContextGL::deleteProgram(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteProgram(arg0);
}

void WebProcessGraphicsContextGL::deleteRenderbuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteRenderbuffer(arg0);
}

void WebProcessGraphicsContextGL::deleteShader(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteShader(arg0);
}

void WebProcessGraphicsContextGL::deleteTexture(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteTexture(arg0);
}

void WebProcessGraphicsContextGL::depthFunc(GCGLenum func)
{
    if (!makeContextCurrent())
        return;
    m_context->depthFunc(func);
}

void WebProcessGraphicsContextGL::depthMask(GCGLboolean flag)
{
    if (!makeContextCurrent())
        return;
    m_context->depthMask(flag);
}

void WebProcessGraphicsContextGL::depthRange(GCGLclampf zNear, GCGLclampf zFar)
{
    if (!makeContextCurrent())
        return;
    m_context->depthRange(zNear, zFar);
}

void WebProcessGraphicsContextGL::detachShader(PlatformGLObject arg0, PlatformGLObject arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->detachShader(arg0, arg1);
}

void WebProcessGraphicsContextGL::disable(GCGLenum cap)
{
    if (!makeContextCurrent())
        return;
    m_context->disable(cap);
}

void WebProcessGraphicsContextGL::disableVertexAttribArray(GCGLuint index)
{
    if (!makeContextCurrent())
        return;
    m_context->disableVertexAttribArray(index);
}

void WebProcessGraphicsContextGL::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)
{
    if (!makeContextCurrent())
        return;
    m_context->drawArrays(mode, first, count);
}

void WebProcessGraphicsContextGL::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->drawElements(mode, count, type, offset);
}

void WebProcessGraphicsContextGL::enable(GCGLenum cap)
{
    if (!makeContextCurrent())
        return;
    m_context->enable(cap);
}

void WebProcessGraphicsContextGL::enableVertexAttribArray(GCGLuint index)
{
    if (!makeContextCurrent())
        return;
    m_context->enableVertexAttribArray(index);
}

void WebProcessGraphicsContextGL::finish()
{
    if (!makeContextCurrent())
        return;
    m_context->finish();
}

void WebProcessGraphicsContextGL::flush()
{
    if (!makeContextCurrent())
        return;
    m_context->flush();
}

void WebProcessGraphicsContextGL::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, PlatformGLObject arg3)
{
    if (!makeContextCurrent())
        return;
    m_context->framebufferRenderbuffer(target, attachment, renderbuffertarget, arg3);
}

void WebProcessGraphicsContextGL::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, PlatformGLObject arg3, GCGLint level)
{
    if (!makeContextCurrent())
        return;
    m_context->framebufferTexture2D(target, attachment, textarget, arg3, level);
}

void WebProcessGraphicsContextGL::frontFace(GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->frontFace(mode);
}

void WebProcessGraphicsContextGL::generateMipmap(GCGLenum target)
{
    if (!makeContextCurrent())
        return;
    m_context->generateMipmap(target);
}

bool WebProcessGraphicsContextGL::getActiveAttrib(PlatformGLObject program, GCGLuint index, GraphicsContextGLActiveInfo& arg2)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getActiveAttrib(program, index, arg2);
}

bool WebProcessGraphicsContextGL::getActiveUniform(PlatformGLObject program, GCGLuint index, GraphicsContextGLActiveInfo& arg2)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getActiveUniform(program, index, arg2);
}

GCGLint WebProcessGraphicsContextGL::getAttribLocation(PlatformGLObject arg0, const String& name)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getAttribLocation(arg0, name);
}

GCGLint WebProcessGraphicsContextGL::getBufferParameteri(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getBufferParameteri(target, pname);
}

String WebProcessGraphicsContextGL::getString(GCGLenum name)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getString(name);
}

void WebProcessGraphicsContextGL::getFloatv(GCGLenum pname, std::span<GCGLfloat> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getFloatv(pname, value);
}

void WebProcessGraphicsContextGL::getIntegerv(GCGLenum pname, std::span<GCGLint> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getIntegerv(pname, value);
}

void WebProcessGraphicsContextGL::getIntegeri_v(GCGLenum pname, GCGLuint index, std::span<GCGLint, 4> value) // NOLINT
{
    if (!makeContextCurrent())
        return;
    m_context->getIntegeri_v(pname, index, value);
}

GCGLint64 WebProcessGraphicsContextGL::getInteger64(GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getInteger64(pname);
}

GCGLint64 WebProcessGraphicsContextGL::getInteger64i(GCGLenum pname, GCGLuint index)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getInteger64i(pname, index);
}

GCGLint WebProcessGraphicsContextGL::getProgrami(PlatformGLObject program, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getProgrami(program, pname);
}

void WebProcessGraphicsContextGL::getBooleanv(GCGLenum pname, std::span<GCGLboolean> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getBooleanv(pname, value);
}

GCGLErrorCodeSet WebProcessGraphicsContextGL::getErrors()
{
    if (!makeContextCurrent())
        return { };
    return m_context->getErrors();
}

GCGLint WebProcessGraphicsContextGL::getFramebufferAttachmentParameteri(GCGLenum target, GCGLenum attachment, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getFramebufferAttachmentParameteri(target, attachment, pname);
}

String WebProcessGraphicsContextGL::getProgramInfoLog(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getProgramInfoLog(arg0);
}

GCGLint WebProcessGraphicsContextGL::getRenderbufferParameteri(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getRenderbufferParameteri(target, pname);
}

GCGLint WebProcessGraphicsContextGL::getShaderi(PlatformGLObject arg0, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getShaderi(arg0, pname);
}

String WebProcessGraphicsContextGL::getShaderInfoLog(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getShaderInfoLog(arg0);
}

void WebProcessGraphicsContextGL::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType, std::span<GCGLint, 2> range, GCGLint* precision)
{
    if (!makeContextCurrent())
        return;
    m_context->getShaderPrecisionFormat(shaderType, precisionType, range, precision);
}

String WebProcessGraphicsContextGL::getShaderSource(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getShaderSource(arg0);
}

GCGLfloat WebProcessGraphicsContextGL::getTexParameterf(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getTexParameterf(target, pname);
}

GCGLint WebProcessGraphicsContextGL::getTexParameteri(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getTexParameteri(target, pname);
}

void WebProcessGraphicsContextGL::getUniformfv(PlatformGLObject program, GCGLint location, std::span<GCGLfloat> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getUniformfv(program, location, value);
}

void WebProcessGraphicsContextGL::getUniformiv(PlatformGLObject program, GCGLint location, std::span<GCGLint> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getUniformiv(program, location, value);
}

void WebProcessGraphicsContextGL::getUniformuiv(PlatformGLObject program, GCGLint location, std::span<GCGLuint> value)
{
    if (!makeContextCurrent())
        return;
    m_context->getUniformuiv(program, location, value);
}

GCGLint WebProcessGraphicsContextGL::getUniformLocation(PlatformGLObject arg0, const String& name)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getUniformLocation(arg0, name);
}

GCGLsizeiptr WebProcessGraphicsContextGL::getVertexAttribOffset(GCGLuint index, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getVertexAttribOffset(index, pname);
}

void WebProcessGraphicsContextGL::hint(GCGLenum target, GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->hint(target, mode);
}

GCGLboolean WebProcessGraphicsContextGL::isBuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isBuffer(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isEnabled(GCGLenum cap)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isEnabled(cap);
}

GCGLboolean WebProcessGraphicsContextGL::isFramebuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isFramebuffer(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isProgram(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isProgram(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isRenderbuffer(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isRenderbuffer(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isShader(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isShader(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isTexture(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isTexture(arg0);
}

void WebProcessGraphicsContextGL::lineWidth(GCGLfloat arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->lineWidth(arg0);
}

void WebProcessGraphicsContextGL::linkProgram(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->linkProgram(arg0);
}

void WebProcessGraphicsContextGL::pixelStorei(GCGLenum pname, GCGLint param)
{
    if (!makeContextCurrent())
        return;
    m_context->pixelStorei(pname, param);
}

void WebProcessGraphicsContextGL::polygonOffset(GCGLfloat factor, GCGLfloat units)
{
    if (!makeContextCurrent())
        return;
    m_context->polygonOffset(factor, units);
}

void WebProcessGraphicsContextGL::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->renderbufferStorage(target, internalformat, width, height);
}

void WebProcessGraphicsContextGL::sampleCoverage(GCGLclampf value, GCGLboolean invert)
{
    if (!makeContextCurrent())
        return;
    m_context->sampleCoverage(value, invert);
}

void WebProcessGraphicsContextGL::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->scissor(x, y, width, height);
}

void WebProcessGraphicsContextGL::shaderSource(PlatformGLObject arg0, const String& string)
{
    if (!makeContextCurrent())
        return;
    m_context->shaderSource(arg0, string);
}

void WebProcessGraphicsContextGL::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilFunc(func, ref, mask);
}

void WebProcessGraphicsContextGL::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilFuncSeparate(face, func, ref, mask);
}

void WebProcessGraphicsContextGL::stencilMask(GCGLuint mask)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilMask(mask);
}

void WebProcessGraphicsContextGL::stencilMaskSeparate(GCGLenum face, GCGLuint mask)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilMaskSeparate(face, mask);
}

void WebProcessGraphicsContextGL::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilOp(fail, zfail, zpass);
}

void WebProcessGraphicsContextGL::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
{
    if (!makeContextCurrent())
        return;
    m_context->stencilOpSeparate(face, fail, zfail, zpass);
}

void WebProcessGraphicsContextGL::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param)
{
    if (!makeContextCurrent())
        return;
    m_context->texParameterf(target, pname, param);
}

void WebProcessGraphicsContextGL::texParameteri(GCGLenum target, GCGLenum pname, GCGLint param)
{
    if (!makeContextCurrent())
        return;
    m_context->texParameteri(target, pname, param);
}

void WebProcessGraphicsContextGL::uniform1f(GCGLint location, GCGLfloat x)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1f(location, x);
}

void WebProcessGraphicsContextGL::uniform1fv(GCGLint location, std::span<const GCGLfloat> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1fv(location, v);
}

void WebProcessGraphicsContextGL::uniform1i(GCGLint location, GCGLint x)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1i(location, x);
}

void WebProcessGraphicsContextGL::uniform1iv(GCGLint location, std::span<const GCGLint> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1iv(location, v);
}

void WebProcessGraphicsContextGL::uniform2f(GCGLint location, GCGLfloat x, GCGLfloat y)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2f(location, x, y);
}

void WebProcessGraphicsContextGL::uniform2fv(GCGLint location, std::span<const GCGLfloat> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2fv(location, v);
}

void WebProcessGraphicsContextGL::uniform2i(GCGLint location, GCGLint x, GCGLint y)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2i(location, x, y);
}

void WebProcessGraphicsContextGL::uniform2iv(GCGLint location, std::span<const GCGLint> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2iv(location, v);
}

void WebProcessGraphicsContextGL::uniform3f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3f(location, x, y, z);
}

void WebProcessGraphicsContextGL::uniform3fv(GCGLint location, std::span<const GCGLfloat> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3fv(location, v);
}

void WebProcessGraphicsContextGL::uniform3i(GCGLint location, GCGLint x, GCGLint y, GCGLint z)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3i(location, x, y, z);
}

void WebProcessGraphicsContextGL::uniform3iv(GCGLint location, std::span<const GCGLint> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3iv(location, v);
}

void WebProcessGraphicsContextGL::uniform4f(GCGLint location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4f(location, x, y, z, w);
}

void WebProcessGraphicsContextGL::uniform4fv(GCGLint location, std::span<const GCGLfloat> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4fv(location, v);
}

void WebProcessGraphicsContextGL::uniform4i(GCGLint location, GCGLint x, GCGLint y, GCGLint z, GCGLint w)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4i(location, x, y, z, w);
}

void WebProcessGraphicsContextGL::uniform4iv(GCGLint location, std::span<const GCGLint> v)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4iv(location, v);
}

void WebProcessGraphicsContextGL::uniformMatrix2fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> value)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix2fv(location, transpose, value);
}

void WebProcessGraphicsContextGL::uniformMatrix3fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> value)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix3fv(location, transpose, value);
}

void WebProcessGraphicsContextGL::uniformMatrix4fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> value)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix4fv(location, transpose, value);
}

void WebProcessGraphicsContextGL::useProgram(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->useProgram(arg0);
}

void WebProcessGraphicsContextGL::validateProgram(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->validateProgram(arg0);
}

void WebProcessGraphicsContextGL::vertexAttrib1f(GCGLuint index, GCGLfloat x)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib1f(index, x);
}

void WebProcessGraphicsContextGL::vertexAttrib1fv(GCGLuint index, std::span<const GCGLfloat, 1> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib1fv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib2f(index, x, y);
}

void WebProcessGraphicsContextGL::vertexAttrib2fv(GCGLuint index, std::span<const GCGLfloat, 2> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib2fv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib3f(index, x, y, z);
}

void WebProcessGraphicsContextGL::vertexAttrib3fv(GCGLuint index, std::span<const GCGLfloat, 3> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib3fv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib4f(index, x, y, z, w);
}

void WebProcessGraphicsContextGL::vertexAttrib4fv(GCGLuint index, std::span<const GCGLfloat, 4> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttrib4fv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribPointer(index, size, type, normalized, stride, offset);
}

void WebProcessGraphicsContextGL::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->viewport(x, y, width, height);
}

void WebProcessGraphicsContextGL::bufferData(GCGLenum target, GCGLsizeiptr arg1, GCGLenum usage)
{
    if (!makeContextCurrent())
        return;
    m_context->bufferData(target, arg1, usage);
}

void WebProcessGraphicsContextGL::bufferData(GCGLenum target, std::span<const uint8_t> data, GCGLenum usage)
{
    if (!makeContextCurrent())
        return;
    m_context->bufferData(target, data, usage);
}

void WebProcessGraphicsContextGL::bufferSubData(GCGLenum target, GCGLintptr offset, std::span<const uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->bufferSubData(target, offset, data);
}

void WebProcessGraphicsContextGL::readPixels(IntRect arg0, GCGLenum format, GCGLenum type, std::span<uint8_t> data, GCGLint alignment, GCGLint rowLength)
{
    if (!makeContextCurrent())
        return;
    m_context->readPixels(arg0, format, type, data, alignment, rowLength);
}

void WebProcessGraphicsContextGL::readPixelsBufferObject(IntRect arg0, GCGLenum format, GCGLenum type, GCGLintptr offset, GCGLint alignment, GCGLint rowLength)
{
    if (!makeContextCurrent())
        return;
    m_context->readPixelsBufferObject(arg0, format, type, offset, alignment, rowLength);
}

void WebProcessGraphicsContextGL::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, std::span<const uint8_t> pixels)
{
    if (!makeContextCurrent())
        return;
    m_context->texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

void WebProcessGraphicsContextGL::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->texImage2D(target, level, internalformat, width, height, border, format, type, offset);
}

void WebProcessGraphicsContextGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, std::span<const uint8_t> pixels)
{
    if (!makeContextCurrent())
        return;
    m_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void WebProcessGraphicsContextGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, offset);
}

void WebProcessGraphicsContextGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, std::span<const uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

void WebProcessGraphicsContextGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexImage2D(target, level, internalformat, width, height, border, imageSize, offset);
}

void WebProcessGraphicsContextGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, std::span<const uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

void WebProcessGraphicsContextGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, offset);
}

void WebProcessGraphicsContextGL::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
{
    if (!makeContextCurrent())
        return;
    m_context->drawArraysInstanced(mode, first, count, primcount);
}

void WebProcessGraphicsContextGL::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei primcount)
{
    if (!makeContextCurrent())
        return;
    m_context->drawElementsInstanced(mode, count, type, offset, primcount);
}

void WebProcessGraphicsContextGL::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribDivisor(index, divisor);
}

PlatformGLObject WebProcessGraphicsContextGL::createVertexArray()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createVertexArray();
}

void WebProcessGraphicsContextGL::deleteVertexArray(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteVertexArray(arg0);
}

GCGLboolean WebProcessGraphicsContextGL::isVertexArray(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isVertexArray(arg0);
}

void WebProcessGraphicsContextGL::bindVertexArray(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->bindVertexArray(arg0);
}

void WebProcessGraphicsContextGL::copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)
{
    if (!makeContextCurrent())
        return;
    m_context->copyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}

void WebProcessGraphicsContextGL::getBufferSubData(GCGLenum target, GCGLintptr offset, std::span<uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->getBufferSubData(target, offset, data);
}

void WebProcessGraphicsContextGL::blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter)
{
    if (!makeContextCurrent())
        return;
    m_context->blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void WebProcessGraphicsContextGL::framebufferTextureLayer(GCGLenum target, GCGLenum attachment, PlatformGLObject texture, GCGLint level, GCGLint layer)
{
    if (!makeContextCurrent())
        return;
    m_context->framebufferTextureLayer(target, attachment, texture, level, layer);
}

void WebProcessGraphicsContextGL::invalidateFramebuffer(GCGLenum target, std::span<const GCGLenum> attachments)
{
    if (!makeContextCurrent())
        return;
    m_context->invalidateFramebuffer(target, attachments);
}

void WebProcessGraphicsContextGL::invalidateSubFramebuffer(GCGLenum target, std::span<const GCGLenum> attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->invalidateSubFramebuffer(target, attachments, x, y, width, height);
}

void WebProcessGraphicsContextGL::readBuffer(GCGLenum src)
{
    if (!makeContextCurrent())
        return;
    m_context->readBuffer(src);
}

void WebProcessGraphicsContextGL::getInternalformativ(GCGLenum target, GCGLenum internalformat, GCGLenum pname, std::span<GCGLint> data)
{
    if (!makeContextCurrent())
        return;
    m_context->getInternalformativ(target, internalformat, pname, data);
}

void WebProcessGraphicsContextGL::renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->renderbufferStorageMultisample(target, samples, internalformat, width, height);
}

void WebProcessGraphicsContextGL::texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->texStorage2D(target, levels, internalformat, width, height);
}

void WebProcessGraphicsContextGL::texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth)
{
    if (!makeContextCurrent())
        return;
    m_context->texStorage3D(target, levels, internalformat, width, height, depth);
}

void WebProcessGraphicsContextGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, std::span<const uint8_t> pixels)
{
    if (!makeContextCurrent())
        return;
    m_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

void WebProcessGraphicsContextGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->texImage3D(target, level, internalformat, width, height, depth, border, format, type, offset);
}

void WebProcessGraphicsContextGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, std::span<const uint8_t> pixels)
{
    if (!makeContextCurrent())
        return;
    m_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

void WebProcessGraphicsContextGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->texSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
}

void WebProcessGraphicsContextGL::copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->copyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

void WebProcessGraphicsContextGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, std::span<const uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}

void WebProcessGraphicsContextGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, offset);
}

void WebProcessGraphicsContextGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, std::span<const uint8_t> data)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

void WebProcessGraphicsContextGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->compressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, offset);
}

GCGLint WebProcessGraphicsContextGL::getFragDataLocation(PlatformGLObject program, const String& name)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getFragDataLocation(program, name);
}

void WebProcessGraphicsContextGL::uniform1ui(GCGLint location, GCGLuint v0)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1ui(location, v0);
}

void WebProcessGraphicsContextGL::uniform2ui(GCGLint location, GCGLuint v0, GCGLuint v1)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2ui(location, v0, v1);
}

void WebProcessGraphicsContextGL::uniform3ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3ui(location, v0, v1, v2);
}

void WebProcessGraphicsContextGL::uniform4ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4ui(location, v0, v1, v2, v3);
}

void WebProcessGraphicsContextGL::uniform1uiv(GCGLint location, std::span<const GCGLuint> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform1uiv(location, data);
}

void WebProcessGraphicsContextGL::uniform2uiv(GCGLint location, std::span<const GCGLuint> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform2uiv(location, data);
}

void WebProcessGraphicsContextGL::uniform3uiv(GCGLint location, std::span<const GCGLuint> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform3uiv(location, data);
}

void WebProcessGraphicsContextGL::uniform4uiv(GCGLint location, std::span<const GCGLuint> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniform4uiv(location, data);
}

void WebProcessGraphicsContextGL::uniformMatrix2x3fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix2x3fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::uniformMatrix3x2fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix3x2fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::uniformMatrix2x4fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix2x4fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::uniformMatrix4x2fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix4x2fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::uniformMatrix3x4fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix3x4fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::uniformMatrix4x3fv(GCGLint location, GCGLboolean transpose, std::span<const GCGLfloat> data)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformMatrix4x3fv(location, transpose, data);
}

void WebProcessGraphicsContextGL::vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribI4i(index, x, y, z, w);
}

void WebProcessGraphicsContextGL::vertexAttribI4iv(GCGLuint index, std::span<const GCGLint, 4> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribI4iv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribI4ui(index, x, y, z, w);
}

void WebProcessGraphicsContextGL::vertexAttribI4uiv(GCGLuint index, std::span<const GCGLuint, 4> values)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribI4uiv(index, values);
}

void WebProcessGraphicsContextGL::vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->vertexAttribIPointer(index, size, type, stride, offset);
}

void WebProcessGraphicsContextGL::drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLintptr offset)
{
    if (!makeContextCurrent())
        return;
    m_context->drawRangeElements(mode, start, end, count, type, offset);
}

void WebProcessGraphicsContextGL::drawBuffers(std::span<const GCGLenum> bufs)
{
    if (!makeContextCurrent())
        return;
    m_context->drawBuffers(bufs);
}

void WebProcessGraphicsContextGL::clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, std::span<const GCGLint> values)
{
    if (!makeContextCurrent())
        return;
    m_context->clearBufferiv(buffer, drawbuffer, values);
}

void WebProcessGraphicsContextGL::clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, std::span<const GCGLuint> values)
{
    if (!makeContextCurrent())
        return;
    m_context->clearBufferuiv(buffer, drawbuffer, values);
}

void WebProcessGraphicsContextGL::clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, std::span<const GCGLfloat> values)
{
    if (!makeContextCurrent())
        return;
    m_context->clearBufferfv(buffer, drawbuffer, values);
}

void WebProcessGraphicsContextGL::clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil)
{
    if (!makeContextCurrent())
        return;
    m_context->clearBufferfi(buffer, drawbuffer, depth, stencil);
}

PlatformGLObject WebProcessGraphicsContextGL::createQuery()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createQuery();
}

void WebProcessGraphicsContextGL::deleteQuery(PlatformGLObject query)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteQuery(query);
}

GCGLboolean WebProcessGraphicsContextGL::isQuery(PlatformGLObject query)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isQuery(query);
}

void WebProcessGraphicsContextGL::beginQuery(GCGLenum target, PlatformGLObject query)
{
    if (!makeContextCurrent())
        return;
    m_context->beginQuery(target, query);
}

void WebProcessGraphicsContextGL::endQuery(GCGLenum target)
{
    if (!makeContextCurrent())
        return;
    m_context->endQuery(target);
}

GCGLint WebProcessGraphicsContextGL::getQuery(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getQuery(target, pname);
}

GCGLuint WebProcessGraphicsContextGL::getQueryObjectui(PlatformGLObject query, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getQueryObjectui(query, pname);
}

PlatformGLObject WebProcessGraphicsContextGL::createSampler()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createSampler();
}

void WebProcessGraphicsContextGL::deleteSampler(PlatformGLObject sampler)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteSampler(sampler);
}

GCGLboolean WebProcessGraphicsContextGL::isSampler(PlatformGLObject sampler)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isSampler(sampler);
}

void WebProcessGraphicsContextGL::bindSampler(GCGLuint unit, PlatformGLObject sampler)
{
    if (!makeContextCurrent())
        return;
    m_context->bindSampler(unit, sampler);
}

void WebProcessGraphicsContextGL::samplerParameteri(PlatformGLObject sampler, GCGLenum pname, GCGLint param)
{
    if (!makeContextCurrent())
        return;
    m_context->samplerParameteri(sampler, pname, param);
}

void WebProcessGraphicsContextGL::samplerParameterf(PlatformGLObject sampler, GCGLenum pname, GCGLfloat param)
{
    if (!makeContextCurrent())
        return;
    m_context->samplerParameterf(sampler, pname, param);
}

GCGLfloat WebProcessGraphicsContextGL::getSamplerParameterf(PlatformGLObject sampler, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getSamplerParameterf(sampler, pname);
}

GCGLint WebProcessGraphicsContextGL::getSamplerParameteri(PlatformGLObject sampler, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getSamplerParameteri(sampler, pname);
}

GCGLsync WebProcessGraphicsContextGL::fenceSync(GCGLenum condition, GCGLbitfield flags)
{
    if (!makeContextCurrent())
        return { };
    return m_context->fenceSync(condition, flags);
}

GCGLboolean WebProcessGraphicsContextGL::isSync(GCGLsync arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isSync(arg0);
}

void WebProcessGraphicsContextGL::deleteSync(GCGLsync arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteSync(arg0);
}

GCGLenum WebProcessGraphicsContextGL::clientWaitSync(GCGLsync arg0, GCGLbitfield flags, GCGLuint64 timeout)
{
    if (!makeContextCurrent())
        return { };
    return m_context->clientWaitSync(arg0, flags, timeout);
}

void WebProcessGraphicsContextGL::waitSync(GCGLsync arg0, GCGLbitfield flags, GCGLint64 timeout)
{
    if (!makeContextCurrent())
        return;
    m_context->waitSync(arg0, flags, timeout);
}

GCGLint WebProcessGraphicsContextGL::getSynci(GCGLsync arg0, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getSynci(arg0, pname);
}

PlatformGLObject WebProcessGraphicsContextGL::createTransformFeedback()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createTransformFeedback();
}

void WebProcessGraphicsContextGL::deleteTransformFeedback(PlatformGLObject id)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteTransformFeedback(id);
}

GCGLboolean WebProcessGraphicsContextGL::isTransformFeedback(PlatformGLObject id)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isTransformFeedback(id);
}

void WebProcessGraphicsContextGL::bindTransformFeedback(GCGLenum target, PlatformGLObject id)
{
    if (!makeContextCurrent())
        return;
    m_context->bindTransformFeedback(target, id);
}

void WebProcessGraphicsContextGL::beginTransformFeedback(GCGLenum primitiveMode)
{
    if (!makeContextCurrent())
        return;
    m_context->beginTransformFeedback(primitiveMode);
}

void WebProcessGraphicsContextGL::endTransformFeedback()
{
    if (!makeContextCurrent())
        return;
    m_context->endTransformFeedback();
}

void WebProcessGraphicsContextGL::transformFeedbackVaryings(PlatformGLObject program, const Vector<String>& varyings, GCGLenum bufferMode)
{
    if (!makeContextCurrent())
        return;
    m_context->transformFeedbackVaryings(program, varyings, bufferMode);
}

void WebProcessGraphicsContextGL::getTransformFeedbackVarying(PlatformGLObject program, GCGLuint index, GraphicsContextGLActiveInfo& arg2)
{
    if (!makeContextCurrent())
        return;
    m_context->getTransformFeedbackVarying(program, index, arg2);
}

void WebProcessGraphicsContextGL::pauseTransformFeedback()
{
    if (!makeContextCurrent())
        return;
    m_context->pauseTransformFeedback();
}

void WebProcessGraphicsContextGL::resumeTransformFeedback()
{
    if (!makeContextCurrent())
        return;
    m_context->resumeTransformFeedback();
}

void WebProcessGraphicsContextGL::bindBufferBase(GCGLenum target, GCGLuint index, PlatformGLObject buffer)
{
    if (!makeContextCurrent())
        return;
    m_context->bindBufferBase(target, index, buffer);
}

void WebProcessGraphicsContextGL::bindBufferRange(GCGLenum target, GCGLuint index, PlatformGLObject buffer, GCGLintptr offset, GCGLsizeiptr size)
{
    if (!makeContextCurrent())
        return;
    m_context->bindBufferRange(target, index, buffer, offset, size);
}

Vector<GCGLuint> WebProcessGraphicsContextGL::getUniformIndices(PlatformGLObject program, const Vector<String>& uniformNames)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getUniformIndices(program, uniformNames);
}

Vector<GCGLint> WebProcessGraphicsContextGL::getActiveUniforms(PlatformGLObject program, const Vector<GCGLuint>& uniformIndices, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getActiveUniforms(program, uniformIndices, pname);
}

GCGLuint WebProcessGraphicsContextGL::getUniformBlockIndex(PlatformGLObject program, const String& uniformBlockName)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getUniformBlockIndex(program, uniformBlockName);
}

String WebProcessGraphicsContextGL::getActiveUniformBlockName(PlatformGLObject program, GCGLuint uniformBlockIndex)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getActiveUniformBlockName(program, uniformBlockIndex);
}

void WebProcessGraphicsContextGL::uniformBlockBinding(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding)
{
    if (!makeContextCurrent())
        return;
    m_context->uniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

void WebProcessGraphicsContextGL::getActiveUniformBlockiv(GCGLuint program, GCGLuint uniformBlockIndex, GCGLenum pname, std::span<GCGLint> params)
{
    if (!makeContextCurrent())
        return;
    m_context->getActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}

std::optional<GCEGLImageAttachResult> WebProcessGraphicsContextGL::createAndBindEGLImage(GCGLenum arg0, GCEGLImageSource arg1)
{
    if (!makeContextCurrent())
        return { };
    return m_context->createAndBindEGLImage(arg0, arg1);
}

void WebProcessGraphicsContextGL::destroyEGLImage(GCEGLImage arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->destroyEGLImage(arg0);
}

GCEGLSync WebProcessGraphicsContextGL::createEGLSync(GCExternalEGLSyncEvent arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->createEGLSync(arg0);
}

bool WebProcessGraphicsContextGL::destroyEGLSync(GCEGLSync arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->destroyEGLSync(arg0);
}

void WebProcessGraphicsContextGL::clientWaitEGLSyncWithFlush(GCEGLSync arg0, uint64_t arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->clientWaitEGLSyncWithFlush(arg0, arg1);
}

void WebProcessGraphicsContextGL::multiDrawArraysANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLint, const GCGLsizei> firstsAndCounts)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawArraysANGLE(mode, firstsAndCounts);
}

void WebProcessGraphicsContextGL::multiDrawArraysInstancedANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLint, const GCGLsizei, const GCGLsizei> firstsCountsAndInstanceCounts)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawArraysInstancedANGLE(mode, firstsCountsAndInstanceCounts);
}

void WebProcessGraphicsContextGL::multiDrawElementsANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLsizei, const GCGLsizei> countsAndOffsets, GCGLenum type)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawElementsANGLE(mode, countsAndOffsets, type);
}

void WebProcessGraphicsContextGL::multiDrawElementsInstancedANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLsizei, const GCGLsizei, const GCGLsizei> countsOffsetsAndInstanceCounts, GCGLenum type)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawElementsInstancedANGLE(mode, countsOffsetsAndInstanceCounts, type);
}

bool WebProcessGraphicsContextGL::supportsExtension(const String& arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->supportsExtension(arg0);
}

void WebProcessGraphicsContextGL::ensureExtensionEnabled(const String& arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->ensureExtensionEnabled(arg0);
}

bool WebProcessGraphicsContextGL::isExtensionEnabled(const String& arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isExtensionEnabled(arg0);
}

bool WebProcessGraphicsContextGL::enableRequiredWebXRExtensions()
{
    if (!makeContextCurrent())
        return { };
    return m_context->enableRequiredWebXRExtensions();
}

String WebProcessGraphicsContextGL::getTranslatedShaderSourceANGLE(PlatformGLObject arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getTranslatedShaderSourceANGLE(arg0);
}

void WebProcessGraphicsContextGL::drawBuffersEXT(std::span<const GCGLenum> bufs)
{
    if (!makeContextCurrent())
        return;
    m_context->drawBuffersEXT(bufs);
}

PlatformGLObject WebProcessGraphicsContextGL::createQueryEXT()
{
    if (!makeContextCurrent())
        return { };
    return m_context->createQueryEXT();
}

void WebProcessGraphicsContextGL::deleteQueryEXT(PlatformGLObject query)
{
    if (!makeContextCurrent())
        return;
    m_context->deleteQueryEXT(query);
}

GCGLboolean WebProcessGraphicsContextGL::isQueryEXT(PlatformGLObject query)
{
    if (!makeContextCurrent())
        return { };
    return m_context->isQueryEXT(query);
}

void WebProcessGraphicsContextGL::beginQueryEXT(GCGLenum target, PlatformGLObject query)
{
    if (!makeContextCurrent())
        return;
    m_context->beginQueryEXT(target, query);
}

void WebProcessGraphicsContextGL::endQueryEXT(GCGLenum target)
{
    if (!makeContextCurrent())
        return;
    m_context->endQueryEXT(target);
}

void WebProcessGraphicsContextGL::queryCounterEXT(PlatformGLObject query, GCGLenum target)
{
    if (!makeContextCurrent())
        return;
    m_context->queryCounterEXT(query, target);
}

GCGLint WebProcessGraphicsContextGL::getQueryiEXT(GCGLenum target, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getQueryiEXT(target, pname);
}

GCGLint WebProcessGraphicsContextGL::getQueryObjectiEXT(PlatformGLObject query, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getQueryObjectiEXT(query, pname);
}

GCGLuint64 WebProcessGraphicsContextGL::getQueryObjectui64EXT(PlatformGLObject query, GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getQueryObjectui64EXT(query, pname);
}

GCGLint64 WebProcessGraphicsContextGL::getInteger64EXT(GCGLenum pname)
{
    if (!makeContextCurrent())
        return { };
    return m_context->getInteger64EXT(pname);
}

void WebProcessGraphicsContextGL::enableiOES(GCGLenum target, GCGLuint index)
{
    if (!makeContextCurrent())
        return;
    m_context->enableiOES(target, index);
}

void WebProcessGraphicsContextGL::disableiOES(GCGLenum target, GCGLuint index)
{
    if (!makeContextCurrent())
        return;
    m_context->disableiOES(target, index);
}

void WebProcessGraphicsContextGL::blendEquationiOES(GCGLuint buf, GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->blendEquationiOES(buf, mode);
}

void WebProcessGraphicsContextGL::blendEquationSeparateiOES(GCGLuint buf, GCGLenum modeRGB, GCGLenum modeAlpha)
{
    if (!makeContextCurrent())
        return;
    m_context->blendEquationSeparateiOES(buf, modeRGB, modeAlpha);
}

void WebProcessGraphicsContextGL::blendFunciOES(GCGLuint buf, GCGLenum src, GCGLenum dst)
{
    if (!makeContextCurrent())
        return;
    m_context->blendFunciOES(buf, src, dst);
}

void WebProcessGraphicsContextGL::blendFuncSeparateiOES(GCGLuint buf, GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)
{
    if (!makeContextCurrent())
        return;
    m_context->blendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void WebProcessGraphicsContextGL::colorMaskiOES(GCGLuint buf, GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)
{
    if (!makeContextCurrent())
        return;
    m_context->colorMaskiOES(buf, red, green, blue, alpha);
}

void WebProcessGraphicsContextGL::drawArraysInstancedBaseInstanceANGLE(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei instanceCount, GCGLuint baseInstance)
{
    if (!makeContextCurrent())
        return;
    m_context->drawArraysInstancedBaseInstanceANGLE(mode, first, count, instanceCount, baseInstance);
}

void WebProcessGraphicsContextGL::drawElementsInstancedBaseVertexBaseInstanceANGLE(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei instanceCount, GCGLint baseVertex, GCGLuint baseInstance)
{
    if (!makeContextCurrent())
        return;
    m_context->drawElementsInstancedBaseVertexBaseInstanceANGLE(mode, count, type, offset, instanceCount, baseVertex, baseInstance);
}

void WebProcessGraphicsContextGL::multiDrawArraysInstancedBaseInstanceANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLint, const GCGLsizei, const GCGLsizei, const GCGLuint> firstsCountsInstanceCountsAndBaseInstances)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawArraysInstancedBaseInstanceANGLE(mode, firstsCountsInstanceCountsAndBaseInstances);
}

void WebProcessGraphicsContextGL::multiDrawElementsInstancedBaseVertexBaseInstanceANGLE(GCGLenum mode, GCGLSpanTuple<const GCGLsizei, const GCGLsizei, const GCGLsizei, const GCGLint, const GCGLuint> countsOffsetsInstanceCountsBaseVerticesAndBaseInstances, GCGLenum type)
{
    if (!makeContextCurrent())
        return;
    m_context->multiDrawElementsInstancedBaseVertexBaseInstanceANGLE(mode, countsOffsetsInstanceCountsBaseVerticesAndBaseInstances, type);
}

void WebProcessGraphicsContextGL::clipControlEXT(GCGLenum origin, GCGLenum depth)
{
    if (!makeContextCurrent())
        return;
    m_context->clipControlEXT(origin, depth);
}

void WebProcessGraphicsContextGL::provokingVertexANGLE(GCGLenum provokeMode)
{
    if (!makeContextCurrent())
        return;
    m_context->provokingVertexANGLE(provokeMode);
}

void WebProcessGraphicsContextGL::polygonModeANGLE(GCGLenum face, GCGLenum mode)
{
    if (!makeContextCurrent())
        return;
    m_context->polygonModeANGLE(face, mode);
}

void WebProcessGraphicsContextGL::polygonOffsetClampEXT(GCGLfloat factor, GCGLfloat units, GCGLfloat clamp)
{
    if (!makeContextCurrent())
        return;
    m_context->polygonOffsetClampEXT(factor, units, clamp);
}

void WebProcessGraphicsContextGL::renderbufferStorageMultisampleANGLE(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
{
    if (!makeContextCurrent())
        return;
    m_context->renderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
}

void WebProcessGraphicsContextGL::blitFramebufferANGLE(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter)
{
    if (!makeContextCurrent())
        return;
    m_context->blitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void WebProcessGraphicsContextGL::reshape(int width, int height)
{
    if (!makeContextCurrent())
        return;
    m_context->reshape(width, height);
}

void WebProcessGraphicsContextGL::setContextVisibility(bool arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->setContextVisibility(arg0);
}

void WebProcessGraphicsContextGL::setDrawingBufferColorSpace(const DestinationColorSpace& arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->setDrawingBufferColorSpace(arg0);
}

void WebProcessGraphicsContextGL::prepareForDisplay()
{
    if (!makeContextCurrent())
        return;
    m_context->prepareForDisplay();
}

void WebProcessGraphicsContextGL::drawSurfaceBufferToImageBuffer(SurfaceBuffer arg0, ImageBuffer& arg1)
{
    if (!makeContextCurrent())
        return;
    m_context->drawSurfaceBufferToImageBuffer(arg0, arg1);
}

RefPtr<PixelBuffer> WebProcessGraphicsContextGL::drawingBufferToPixelBuffer(FlipY arg0)
{
    if (!makeContextCurrent())
        return { };
    return m_context->drawingBufferToPixelBuffer(arg0);
}

void WebProcessGraphicsContextGL::simulateEventForTesting(SimulatedEventForTesting arg0)
{
    if (!makeContextCurrent())
        return;
    m_context->simulateEventForTesting(arg0);
}

}

